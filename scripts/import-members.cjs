#!/usr/bin/env node

/**
 * Import members from tmp/members-import.json into Firebase Auth + Firestore.
 *
 * This script:
 * 1. Creates Firebase Auth users (email + displayName, no password)
 * 2. Creates Firestore 'users' documents matching the existing schema
 * 3. Sets lifecycle status (active for members, collaborator for external)
 * 4. Optionally generates a password reset link (only for the test email)
 *
 * Usage:
 *   node scripts/import-members.cjs --dry-run          # Preview only
 *   node scripts/import-members.cjs                     # Actually import
 *   node scripts/import-members.cjs --emulator          # Target local emulator
 *
 * Prerequisites:
 *   - GOOGLE_APPLICATION_CREDENTIALS env var, or `firebase use <project>`
 *   - tmp/members-import.json (generated by prepare-member-import.py)
 */

const path = require("path");
// Resolve firebase-admin from functions/node_modules
const admin = require(path.resolve(__dirname, "../functions/node_modules/firebase-admin"));
const fs = require("fs");

// --- Config ---
const PROJECT_ID = "secid-org";
const TEST_EMAIL = "artemiopadilla@gmail.com";
const DATA_PATH = path.resolve(__dirname, "../tmp/members-import.json");
const FIREBASE_CONFIG_PATH = path.join(
  process.env.HOME || process.env.USERPROFILE,
  ".config/configstore/firebase-tools.json"
);

// --- Parse args ---
const args = process.argv.slice(2);
const isDryRun = args.includes("--dry-run");
const useEmulator = args.includes("--emulator");

// --- Init Firebase Admin using Firebase CLI credentials ---
if (useEmulator) {
  process.env.FIRESTORE_EMULATOR_HOST = "localhost:8080";
  process.env.FIREBASE_AUTH_EMULATOR_HOST = "localhost:9099";
}

// Firebase CLI OAuth client credentials (public, embedded in the CLI itself)
const FIREBASE_CLIENT_ID = "563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com";
const FIREBASE_CLIENT_SECRET = "j9iVZfS8kkCEFUPaAeJV0sAi";

let tempADCPath = null;

if (!admin.apps.length) {
  if (useEmulator) {
    admin.initializeApp({ projectId: PROJECT_ID });
  } else {
    // Read the Firebase CLI refresh token and expose it as Application Default Credentials
    const firebaseConfig = JSON.parse(fs.readFileSync(FIREBASE_CONFIG_PATH, "utf-8"));
    const refreshToken = firebaseConfig.tokens && firebaseConfig.tokens.refresh_token;
    if (!refreshToken) {
      console.error("No refresh token found. Run: firebase login --reauth");
      process.exit(1);
    }

    // Write a temporary ADC file that Firestore's client library can use
    const adcPayload = {
      type: "authorized_user",
      client_id: FIREBASE_CLIENT_ID,
      client_secret: FIREBASE_CLIENT_SECRET,
      refresh_token: refreshToken,
    };
    tempADCPath = path.resolve(__dirname, "../tmp/.adc-temp.json");
    fs.writeFileSync(tempADCPath, JSON.stringify(adcPayload));
    process.env.GOOGLE_APPLICATION_CREDENTIALS = tempADCPath;

    admin.initializeApp({ projectId: PROJECT_ID });
  }
}

const db = admin.firestore();
const auth = admin.auth();

// --- Helpers ---

function buildFirestoreDoc(member) {
  const now = admin.firestore.FieldValue.serverTimestamp();
  const registeredAt = member.registeredAt
    ? admin.firestore.Timestamp.fromDate(new Date(member.registeredAt))
    : now;

  return {
    // Core fields (matches onUserCreate in functions/src/index.ts)
    email: member.email,
    displayName: member.displayName,
    photoURL: "",
    firstName: member.firstName || "",
    lastName: member.lastName || "",
    role: member.role,
    registrationType: member.registrationType,
    verificationStatus: member.verificationStatus,
    isActive: true,
    isVerified: member.verificationStatus === "approved",
    membershipTier: "free",
    skills: member.skills || [],

    // UNAM-specific
    numeroCuenta: member.numeroCuenta || "",
    academicLevel: member.academicLevel || "",
    campus: member.campus || "",
    generation: member.generation || "",

    // Profile (matches UserProfile.profile)
    profile: {
      firstName: member.firstName || "",
      lastName: member.lastName || "",
      bio: "",
      company: member.company || "",
      position: member.position || "",
      location: "",
      linkedin: member.linkedin || "",
      skills: member.skills || [],
      graduationYear: member.generation ? parseInt(member.generation) : null,
      degree: member.maxDegreeProgram || "",
      specialization: "",
    },

    // Lifecycle (matches MemberLifecycle)
    lifecycle: {
      status: member.lifecycleStatus,
      statusChangedAt: registeredAt,
      statusHistory: [],
      lastActiveDate: registeredAt,
    },

    // Privacy & notification defaults (matches onUserCreate)
    privacySettings: {
      profileVisible: true,
      contactVisible: false,
      jobSearching: false,
      mentorshipAvailable: false,
    },
    notificationSettings: {
      email: true,
      push: false,
      jobMatches: true,
      events: true,
      forums: true,
    },

    // Extended data from the original registration form
    registrationData: {
      gender: member.gender || null,
      professionalStatus: member.professionalStatus || null,
      maxDegree: member.maxDegree || null,
      maxDegreeInstitution: member.maxDegreeInstitution || null,
      maxDegreeProgram: member.maxDegreeProgram || null,
      experienceLevel: member.experienceLevel || null,
      currentlyStudying: member.currentlyStudying || null,
      whatsappConsent: member.whatsappConsent || null,
      objectives: member.objectives || null,
      expectations: member.expectations || null,
      priorities: member.priorities || {},
      comments: member.comments || null,
      birthDate: member.birthDate || null,
      cvUrl: member.cvUrl || null,
      cvHighlights: member.cvHighlights || null,
      phone: member.phone || null,
      socialMedia: {
        linkedin: member.linkedin || null,
        instagram: member.instagram || null,
        twitter: member.twitter || null,
        facebook: member.facebook || null,
      },
    },

    // Timestamps
    createdAt: registeredAt,
    updatedAt: now,
    importedAt: now,
    importSource: "members-xlsx-2025",
    profileCompleteness: calculateCompleteness(member),
  };
}

function calculateCompleteness(member) {
  let score = 20;
  if (member.company) score += 10;
  if (member.position) score += 10;
  if (member.linkedin) score += 10;
  if (member.skills && member.skills.length > 0) score += 10;
  if (member.numeroCuenta) score += 10;
  if (member.maxDegree) score += 5;
  if (member.campus) score += 5;
  if (member.generation) score += 5;
  if (member.phone) score += 5;
  if (member.cvHighlights || member.cvUrl) score += 10;
  return Math.min(score, 100);
}

async function importMembers() {
  console.log(`\n========================================`);
  console.log(`  SECiD Member Import`);
  console.log(`  Mode: ${isDryRun ? "DRY RUN" : "LIVE"}`);
  console.log(`  Target: ${useEmulator ? "EMULATOR" : "PRODUCTION"}`);
  console.log(`========================================\n`);

  if (!fs.existsSync(DATA_PATH)) {
    console.error(`Data file not found: ${DATA_PATH}`);
    console.error("Run: python3 scripts/prepare-member-import.py");
    process.exit(1);
  }

  const data = JSON.parse(fs.readFileSync(DATA_PATH, "utf-8"));
  const members = data.members;

  console.log(`Loaded ${members.length} records (${data.memberCount} members, ${data.collaboratorCount} collaborators)`);
  console.log(`Excluded test emails: ${data.excludedEmails.join(", ")}\n`);

  let created = 0;
  let skipped = 0;
  let errors = 0;
  let resetSent = false;

  for (const member of members) {
    const label = `${member.displayName} <${member.email}>`;

    try {
      if (isDryRun) {
        const doc = buildFirestoreDoc(member);
        console.log(`  WOULD CREATE  ${label}`);
        console.log(`    role=${member.role} lifecycle=${member.lifecycleStatus} cuenta=${member.numeroCuenta || "N/A"} completeness=${doc.profileCompleteness}%`);
        created++;
        continue;
      }

      // Check if auth user already exists
      let uid;
      let authExisted = false;
      try {
        const existingUser = await auth.getUserByEmail(member.email);
        uid = existingUser.uid;
        authExisted = true;
      } catch (e) {
        if (e.code !== "auth/user-not-found") throw e;
      }

      // 1. Create Firebase Auth user if needed
      if (!uid) {
        const userRecord = await auth.createUser({
          email: member.email,
          displayName: member.displayName,
          emailVerified: member.verificationStatus === "approved",
          disabled: false,
        });
        uid = userRecord.uid;
      }

      // 2. Create Firestore document if it doesn't exist
      const existingDoc = await db.collection("users").doc(uid).get();
      if (existingDoc.exists) {
        console.log(`  SKIP  ${label} â€” complete (uid: ${uid})`);
        skipped++;
        continue;
      }

      const firestoreDoc = buildFirestoreDoc(member);
      await db.collection("users").doc(uid).set(firestoreDoc);

      const authNote = authExisted ? " (auth existed, doc created)" : "";
      console.log(`  OK    ${label} -> uid: ${uid} (${member.role}/${member.lifecycleStatus})${authNote}`);

      // 3. Generate password reset link only for test email
      if (member.email.toLowerCase() === TEST_EMAIL.toLowerCase() && !resetSent) {
        try {
          const link = await auth.generatePasswordResetLink(member.email);
          console.log(`  RESET ${member.email} -> ${link}`);
          resetSent = true;
        } catch (e) {
          console.log(`  WARN  Could not generate reset link for ${member.email}: ${e.message}`);
        }
      }

      created++;
    } catch (e) {
      console.error(`  ERROR ${label}: ${e.message}`);
      errors++;
    }
  }

  // Summary
  console.log(`\n========================================`);
  console.log(`  Results`);
  console.log(`========================================`);
  console.log(`  Created:  ${created}`);
  console.log(`  Skipped:  ${skipped} (already exist)`);
  console.log(`  Errors:   ${errors}`);

  if (isDryRun) {
    console.log(`\n  This was a DRY RUN. No changes were made.`);
    console.log(`  Run without --dry-run to apply.\n`);
  } else {
    console.log(`\n  Import complete.`);
    console.log(`  Members can sign in via Google OAuth or password reset.\n`);
  }
}

importMembers()
  .then(() => {
    // Clean up temporary ADC file
    if (tempADCPath && fs.existsSync(tempADCPath)) fs.unlinkSync(tempADCPath);
    process.exit(0);
  })
  .catch((err) => {
    if (tempADCPath && fs.existsSync(tempADCPath)) fs.unlinkSync(tempADCPath);
    console.error("Import failed:", err);
    process.exit(1);
  });
